# Описание условий задачи

Создать программу для работы с бинарным деревом, операцию добавления, удаления, поиска элементов, обход дерева,сбалансировать полученное дерево. Вывести его на экран в виде дерева. 

Удалить все слова, начинающиеся на указанную букву, в исходном и сбалансированном дереве.
Сравнить время удаления, объем памяти. 

Построить хеш-таблицу из слов текстового файла(используя открытую и закрытую
адресацию). Вывести построенную таблицу слов на экран. Осуществить поиск и удаление введенного слова, вывести таблицу. Выполнить программу для различных размерностей таблицы и сравнить время удаления, объем
памяти и количество сравнений при использовании сбалансированных деревьев и хеш-таблиц.

# Описание ТЗ

## Описание входных данных

На вход программе подается выбранная опция действия пользователя  - число от 0 до 22(см. Общий алгоритм данных)

В зависимости от треубемой опции, программа потребует ввести данные:

- Ввод символа - пользователь должен ввести необходимый символ, который может храниться в типе данных char и поддерживаться кодировкой компьютера 

- Ввод слова слова - строка не должна превышать буфер в 200 символов

- Ввод пути к файлу - файл должен существовать, у программы есть право на чтение файла, длина пути не должна превышать буфер в 200 символов

- Замерка производительности - файлы для тестирования должны находиться в папке example_files, фпайл должен называться либо 
"{T}words.txt" либо "{T}_sorted_words.txt", где T - количество слов в файле 

## Описание результирующих данных

Пользователю выдается сообщение об успехе/ошибке при выполнения требуемого действия

- При замере производительности пользователю выводится время поиска для реализации с помощью дерева,сбалансированного дерева и хеш-таблицы

- При выводе состояния дерева или поиска узла результат выводится в файл show.dot в языке описания графов DOT

- При выводе состояния хеш-таблицы выводится размер таблицы, количество занятых ячеек, количество удаленных значений, далее выводятся непустые
ячейки, для каждой ячейки выводится статас ячейки("Занято ключом" или "удалено") и значение в этой ячейке

- При поиске значения в хеш-таблице выводится количество сравнений, за которое был найден элемент и адрес этого элемента

## Описание задачи,реализуемой в программе 

Создание интерфейса для работы с бинарными деревьями, хранящими строки в виде ключей, реализация основных операций работы с деревом: обход дерева, включение, исключение и поиск узлов. Построить и обработать хеш-таблицы,сравнить эффективность поиска в сбалансированных деревьях, в двоичных деревьях поиска и в хеш-таблицах.

## Описание способов обращения к программе

Способ обращения к программе пользователем происходит через исполняемый файл app.exe.

## Описание аварийных ситуаций

- ERROR_MALLOC - ошибка выделения динамической памяти, программа не смогла выделить динамическую память на стек
- ERROR_STR_INPUT - ошибка ввода пути файла/строки, программа не смогла считать строку
- ERROR_FILE - ошибка открытия файла, программа не смогла открыть файл на чтение/запись
- ERROR_STR_SIZE - ошибка размера строки, строка превышает размер буфера
- ERROR_EMPTY - ошибка удаленния из дерева, программа пытается удалить элемент из пустого дерева
- ERROR_EMPTY_STR - ошибка пустой строки, программе на вход была передана пустая строка, нельзя добавить строку 
- ERROR_ALREADY_EXISTS - ошибка добавления,попытка добавить неуникальное значение в таблицу
- ERROR_NO_ELEM  - ошибка поиска и удаления, такого элемента не существует
- Другие ошибки и исключительные ситуации, связанные с операционной системой или другими программами


# Описание внутренних СД

В программме для дерева используется структурный тип данных tree_node_t: 

```c 
struct tree_node_t
{
    char *name;
    int height;
    struct tree_node_t *left;
    struct tree_node_t *right;
};
```
- *name - ключ дерева, хранится в виде указателя на char

- height - высота текущего узла, хранится в виде целочисленной переменной формата int
- *left - указатель на левого потомка/поддерево текущего узла, если узел не имеет левого потомка, указатель равен NULL
- *right - указатель на правого потомка/поддерево текущего узла, если узел не имеет правого потомка, указатель равен NULL


Хеш-таблица построенная на открытой адресации, внутреннее хеширования, коллизии решаются с помощью двойного хеширования

Для хеш-таблицы используется два структурных типа данных:

Hash_node_t - элемент таблицы
```c 
typedef struct
{
    char *key;
    int hash_1;
    int hash_2;
    // 0 = empty
    // 1 = deleted
    // 2 = key
    int cell_state;
}Hash_node_t;
```
- *name - ключ элемента, хранится в виде указателя на char

- hash_1 - значение первой хеш-функции для данного элемента, хранится в виде целочисленной переменной формата int
- hash_2 - значение второй хеш-функции для данного элемента, хранится в виде целочисленной переменной формата int
- cell_state - переменная,характеризующая состояние ячейки, может принимать значения "0" - пустой "1" - удален "2"-содержит ключ,
хранится в виде целочисленной переменной формата int

Hash_table_t - хеш-таблица на открытой адресации

```c 
typedef struct
{
    Hash_node_t **table;
    int deleted_cnt;
    int keysCount;
    int table_size;
}Hash_table_t;
```
- **table - массив указателей на элементы хеш-таблицы

- deleted_cnt - количество удаленных элементов в таблице, хранится в виде целочисленной переменной формата int
- keysCount - количество инициализированных неудаленных элементов, хранится в виде целочисленной переменной формата int
- table_size - количество элементов, на которое было выделена память в таблице, хранится в виде целочисленной переменной формата int

Хеш-таблица построенная на закрытой адресации, внутреннее хеширования, коллизии решаются методом цепочек
Для хеш-таблицы используется два структурных типа данных:

Hash_closed_node_t - элемент таблицы
```c 
typedef struct
{
    char *key;
    int hash;
    void *next;
}Hash_closed_node_t;
```
- *name - ключ элемента, хранится в виде указателя на char

- hash - значение хеш-функции для данного элемента, хранится в виде целочисленной переменной формата int
- *next - переменная,характеризующая состояние связанной с этим элементом ячейки,если следующего элемента нет - переменная принимает значение NULL, хранится в виде указателя на void

Hash_closed_table_t - хеш-таблица на закерытой адресации
```c 
typedef struct
{
    Hash_closed_node_t **table;
    int keysCount;
    int table_size;
}Hash_closed_table_t;
```
- **table - массив указателей на элементы хеш-таблицы

- keysCount - количество инициализированных элементов, хранится в виде целочисленной переменной формата int
- table_size - количество элементов, на которое было выделена память в таблице, хранится в виде целочисленной переменной формата int

# Описание алгоритмов

## Общий алгоритм данных

1. Начинается выполнение программы в функции main. Пользователю предлагается выбрать дальнейшее действие:
- ДЕРЕВО: 

        -1  - Инициализировать дерево из файла 
        -2  - Добавить строку в дерево 
        -3  - Удалить строку из дерева 
        -4  - Вывести дерево в файл show.dot
        -5  - Найти и удалить слова, начинающиеся на заданную букву 
        -6  - Найти узел 
        -7  - in-order обход 
        -8  - Сбалансировать дерево 

- ХЕШ-ТАБЛИЦА: ОТКРЫТАЯ АДРЕСАЦИЯ  

        9  - Инициализировать таблицу из файла
        10 - Найти строку в таблице 
        11 - Добавить строку в таблицу 
        12 - Удалить строку из таблицы 
        13 - Найти и удалить слова, начинающиеся на заданную букву
        14 - Вывести хеш-таблицу 

- ХЕШ-ТАБЛИЦА: ЗАКРЫТАЯ АДРЕСАЦИЯ  

        15  - Инициализировать таблицу из файла
        16 - Найти строку в таблице 
        17 - Добавить строку в таблицу 
        18 - Удалить строку из таблицы 
        19 - Найти и удалить слова, начинающиеся на заданную букву
        20 - Вывести хеш-таблицу 
21 - Замер производительности 

22 - Вывод доступных опций 

В случаем ошибки ввода опции, пользователю предложится ввести опцию заново. 
При выборе опции "0" программа завершает свою работу

###  in-order обход
- На вход подается указатель на корень дерева

- Если текущий узел равен NULL ничего не происходит 
- В противном случае, требуемая функция рекурсивно применяется для левого потомка, затем для текущего узла, затем для правого потомка

###  Поиск узла
- На вход подается указатель на корень дерева и указатель на строку, которую нужно найти

- Возвращается указатель на узел дерева
- До тех пор, пока указатель на дерево не будет равен NULL, сравниваем данные в текущем узле с искомой строкой
- Происходит сравнение добавляемой строки со строкой из текущего узла, если строка равна - возвращается указатель на узел, если больше или меньше - алгоритм применяется для левого или правого потомка


###  Добавление узла в дерево
- На вход подается указатель на корень дерева и указатель на узел Node, который нужно добавить

- Возвращается указатель на корень дерева с добавленным узлом
- Если указатель на дерево равен NULL, возвращается указатель на текущее дерево
- Происходит сравнение добавляемой строки со строкой из текущего узла, если строка равна - не добавляем дубликат, если больше или меньше - функция рекурсивно применяется для левого или правого потомка

###  Удаление строки из дерева
- На вход подается указатель на корень дерева и указатель на строку, которую нужно удалить.

- Возвращается указатель на обновленное дерево, где узел с заданным именем удален.
-  Если указатель на дерево равен NULL, возвращается NULL 
- Происходит сравнение добавляемой строки со строкой из текущего узла, если строка равна - не добавляем дубликат, если больше или меньше - функция рекурсивно применяется для левого или правого потомка
- Если строки равны, применяем алгоритм удаления в зависимости от количества потомков: если у узла нет левого узла, сохраняется указатель на правое поддерево, если у узла нет правого дочернего узла, сохраняется указатель на левое поддерево, иначе программа ищет минимальный узел в правом поддереве, копирует его и рекурсивно удаляет этот узел


###  Инициализация дерева из файла
- На вход подается имя файла , из которого нужно прочитать слова, и указатель на указатель на корень дерева, в которое будут вставляться эти слова.

- До тех пор,пока в файле есть слова: на основе считанного слова создаем узел с пустыми левыми и правыми потомками
- Используем функцию добавления узла в дерево для этого узла

###  Балансировка дерева

- На вход подается указатель на узел дерева

- Возвращается указатель на сбалансированный узел
- Если указатель на узел равен NULL, возвращается NULL
- Обновляется высота узла и рассчитывается его баланс
- Если баланс больше 1 и баланс левого узла больше или равен 0, выполняется правый поворот
- Если баланс меньше -1 и баланс правого узла меньше или равен 0, выполняется левый поворот.
- Если баланс больше 1 и баланс левого узла меньше 0, выполняется левый поворот для левого узла, а затем правый поворот для текущего узла
- Если баланс меньше -1 и баланс правого узла больше 0, выполняется правый поворот для правого узла, а затем левый поворот для текущего узла.

### Левый поворот

- На вход подается указатель на узел дерева

- Возвращается указатель на новый корень, образующийся после левого поворота
- Если указатель на корень равен NULL, возвращается NULL
- Сохраняется указатель на правое поддерево  текущего узла, обозначенное как first.
- Сохраняется указатель на левое поддерево first, обозначенное как second.
- Устанавливаем левое поддерево first на текущий узел.
- Устанавливаем правое поддерево текущего узла на значение second.
- Обновляются высоты текущего узла и нового корня first, используя максимальные высоты их потомков.


### Хеш-функция
- Для каждого элемента строки суммируем умноженные значения ASCII кодов символов на 2


### Поиск элемента в хеш-таблице с открытой адресацией

- На вход подается указатель на таблицу, указатель на строку с искомым элементом и счетчик сравнений

- Возвращается указатель на искомый элемент или NULL, если элемент не найден
- Высчитывается значение хеш-функций для искомого элемента
- До тех пор, пока в ячейке не будет пустой элемент проходимся по таблице с шагом равным значению второй хеш функции
- Если текущая ячейка занятна неудаленным элементом и хранимое значение равно ключу, возвращаем указатель на этот элемент
- Если в цикле не было найдено требуемое значение - возвращаем NULL 

### Поиск элемента в хеш-таблице с закрытой адресацией

- На вход подается указатель на таблицу, указатель на строку с искомым элементом и счетчик сравнений

- Возвращается указатель на искомый элемент или NULL, если элемент не найден
- Высчитывается значение хеш-функций для искомого элемента
- До тех пор, пока в ячейке не будет пустой элемент проходимся по списку, хранящейся в данной позиции 
- Если хранимое значение равно ключу, возвращаем указатель на этот элемент
- Если в цикле не было найдено требуемое значение - возвращаем NULL 

### Удаление элемента из хеш-таблицы с открытой адресацией

- На вход подается указатель на таблицу и указатель на строку с искомым элементом

- Возвращается код ошибки ОК, если элемент успешно удален или ERROR_NO_ELEM, если такого элемента нет
- Высчитывается значение хеш-функций для искомого элемента
- До тех пор, пока в ячейке не будет пустой элемент проходимся по таблице с шагом равным значению второй хеш функции
- Если текущая ячейка занятна неудаленным элементом и хранимое значение равно ключу, устанавливается статус текущей ячейки в "Удалено" и возвращается OK
- Если в цикле не было найдено требуемое значение - возвращаем ERROR_NO_ELEM 

### Удаление элемента из хеш-таблицы с закрытой адресацией

- На вход подается указатель на таблицу и указатель на строку с искомым элементом

- Возвращается код ошибки ОК, если элемент успешно удален или ERROR_NO_ELEM, если такого элемента нет
- Высчитывается значение хеш-функций для искомого элемента
- До тех пор, пока в ячейке не будет пустой элемент проходимся по списку, хранящейся в данной позиции 
- Если хранимое значение равно ключу, элемент удаляется из списка,освобождается из памяти и возвращается OK
- Если в цикле не было найдено требуемое значение - возвращаем ERROR_NO_ELEM 

### Добавление элемента в хеш-таблицу с открытой адресацией

- На вход подается двойной указатель на таблицу и указатель на строку с искомым элементом

- Возвращается код ошибки ОК, если элемент успешно удален или код ошибки, если такой элемент есть или произошла ошибка перевыделения памяти
- Если размер таблицы больше или равен размеру таблицы * rehash_size(rehash_size равен 0.8), то рассматривается количество удаленных элементов, если их больше чем (1-rehash_size) * размер таблицы, то происходит 
реструктуризация хеш-таблицы на тот же размер, в противном случае размер увеличивается до следующего простого числа от allocate_incr * размер таблицы(allocate_incr равен 1.2)
- Высчитывается значение хеш-функций для искомого элемента
- До тех пор, пока в ячейке не будет пустой элемент проходимся по таблице с шагом равным значению второй хеш функции
- Если текущая ячейка занятна тем же элементов, возвращается ошибка ERROR_ALREADY_EXISTS
- Если в ячейке хранится удаленный элемент, устанавливаем переменную first_deleted на значение текущего индекса
- После нахождения элемента записываем элемент на текущее значение индекса, если  first_deleted равно -1, в противном случае элемент записывается на позицию first_deleted

### Добавление элемента в хеш-таблицу с закрытой адресацией

- На вход подается двойной указатель на таблицу и указатель на строку с искомым элементом

- Возвращается код ошибки ОК, если элемент успешно удален или код ошибки, если такой элемент есть или произошла ошибка перевыделения памяти
- Если размер таблицы больше или равен размеру таблицы * rehash_size(rehash_size равен 1.2), то происходит реструктуризация хеш-таблицы на размер
до следующего простого числа от величины allocate_incr * размер таблицы(allocate_incr равен 1.2)
- Высчитывается значение хеш-функций для искомого элемента
- До тех пор, пока в ячейке не будет пустой элемент проходимся по списку
- Если текущая ячейка занятна тем же элементов, возвращается ошибка ERROR_ALREADY_EXISTS
- Добавляем элемент в конец списка, смещаем указатель предпоследнего элемента, если такой есть

### Реструктуризация хеш-таблицы

- На вход подается указатель на старую таблицу и требуемый размер новой таблицы

- Указатель на старую таблицу сохраняется в отдельную переменную
- Выделяется память на новую таблицу, проверяется упешность выделения
- Для каждой из ячеек старой таблицы, содержащий неудаленный ключ вычисляется новое значение ключа
- Определяется позиция записи для данного значения, а затем записывается 
на найденную позицию


# Тестирование


## Положительные тесты

|                 Описание тестов                  |      Ожидаемый результат       |
| :----------------------------------------------: | :----------------------------: |
|   Инициализация дерева  из файла с 10 словами    |     Инициализация успешна      |
|     Инициализация дерева из файла с 1 словом     |     Инициализация успешна      |
|            Добавление строки в дерево            |       Добавление успешно       |
|       Удаление строки из непустого дерева        |        Удаление успешно        |
|                  in-order обход                  | Вывод значений по возрастанию  |
|                    Поиск узла                    |   Вывод узла в файл node.dot   |
|                   Вывод дерева                   | Вывод узла в файл show.dot.dot |
|                Вывод хеш-таблицы                 |   Вывод данных о хеш-таблицы   |
| Инициализация хеш-таблицы  из файла с 10 словами |     Инициализация успешна      |
|  Инициализация хеш-таблицы  из файла с 1 словом  |     Инициализация успешна      |
|         Добавление строки в хеш-таблицу          |       Добавление успешно       |
|     Удаление строки из непустой хеш-таблицы      |        Удаление успешно        |
|               Балансировка дерева                |      Балансировка успешна      |



## Негативные тесты
|                 Описание тестов                 | Ожидаемый код ошибки |
| :---------------------------------------------: | :------------------: |
|           Удаление из пустого дерева            |     ERROR_EMPTY      |
|              Введена пустая строка              |   ERROR_EMPTY_STR    |
|    Введена строка,превышающая размер буфера     |    ERROR_STR_SIZE    |
|   Попытка выделения памяти, вся память занята   |     ERROR_MALLOC     |
|       Попытка открыть несуществующий файл       |      ERROR_FILE      |
|     Попытка открыть файл без права доступа      |      ERROR_FILE      |
|            Удаление из пустого хеша             |    ERROR_NO_ELEM     |
| Удаление несуществующего элемента в хеш-таблице |    ERROR_NO_ELEM     |
|  Поиск несуществующего элемента в хеш-таблице   |    ERROR_NO_ELEM     |
|  Добавление дубирующего элемента в хеш-таблицу  |                      |


# Оценка эффекивности

## Поиск

| Количество элементов | Время (дерево) | Память (дерево) | Сравнения (дерево) | Время (сб. дерево) | Память (сб. дерево) | Сравнения (сб. дерево) | Время (хеш-таблица-откр) | Память (таблица-откр) | Сравнения (таблица-откр) | Время (хеш-таблица-закр) | Память (таблица-закр) | Сравнения (таблица-закр) |
| -------------------- | -------------- | --------------- | ------------------ | ------------------ | ------------------- | ---------------------- | ------------------------ | --------------------- | ------------------------ | ------------------------ | --------------------- | ------------------------ |
| 1                    | 125.900000     | 32              | 1                  | 127.000000         | 32                  | 1                      | 194.000000               | 272                   | 1                        | 168.000000               | 112                   | 1                        |
| Sorted: 1            | 134.060000     | 32              | 2                  | 131.460000         | 32                  | 1                      | 166.000000               | 272                   | 1                        | 134.000000               | 112                   | 1                        |
| 10                   | 567.000000     | 320             | 3                  | 210.000000         | 320                 | 2                      | 309.000000               | 488                   | 2                        | 279.000000               | 328                   | 3                        |
| Sorted: 10           | 793.800000     | 320             | 5                  | 205.800000         | 320                 | 2                      | 107.000000               | 488                   | 1                        | 105.000000               | 328                   | 1                        |
| 25                   | 507.600000     | 800             | 4                  | 188.000000         | 800                 | 3                      | 222.000000               | 928                   | 5                        | 223.000000               | 832                   | 3                        |
| Sorted: 25           | 710.640000     | 800             | 13                 | 184.240000         | 800                 | 3                      | 113.000000               | 928                   | 1                        | 102.000000               | 832                   | 1                        |
| 50                   | 666.900000     | 1600            | 6                  | 247.000000         | 1600                | 3                      | 257.000000               | 1736                  | 16                       | 217.000000               | 1576                  | 3                        |
| Sorted: 50           | 933.660000     | 1600            | 25                 | 242.060000         | 1600                | 3                      | 139.000000               | 1736                  | 2                        | 130.000000               | 1576                  | 1                        |
| 100                  | 791.100000     | 3200            | 7                  | 293.000000         | 3200                | 4                      | 272.000000               | 3656                  | 9                        | 268.000000               | 3256                  | 4                        |
| Sorted: 100          | 1107.540000    | 3200            | 50                 | 287.140000         | 3200                | 4                      | 150.000000               | 3656                  | 1                        | 140.000000               | 3256                  | 1                        |
| 250                  | 845.100000     | 8000            | 9                  | 313.000000         | 8000                | 6                      | 295.000000               | 8776                  | 18                       | 329.000000               | 8008                  | 5                        |
| Sorted: 250          | 1183.140000    | 8000            | 125                | 306.740000         | 8000                | 6                      | 154.000000               | 8776                  | 1                        | 140.000000               | 8008                  | 1                        |
| 500                  | 999.000000     | 16000           | 11                 | 370.000000         | 16000               | 7                      | 363.000000               | 17864                 | 18                       | 342.000000               | 16552                 | 4                        |
| Sorted: 500          | 1398.600000    | 16000           | 250                | 362.600000         | 16000               | 7                      | 179.000000               | 17864                 | 1                        | 152.000000               | 16552                 | 1                        |

## Удаление

| Количество элементов | Время (дерево) | Память (дерево) | Сравнения (дерево) | Время (сб. дерево) | Память (сб. дерево) | Сравнения (сб. дерево) | Время (хеш-таблица-откр) | Память (таблица-откр) | Сравнения (таблица-откр) | Время(хеш-таблица-закр) | Память (таблица-закр) | Сравнения (таблица-закр) |
| -------------------- | -------------- | --------------- | ------------------ | ------------------ | ------------------- | ---------------------- | ------------------------ | --------------------- | ------------------------ | ------------------------ | --------------------- | ------------------------ |
| 1                    | 357.000000     | 32              | 1                  | 401.000000         | 32                  | 1                      | 176.000000               | 272                   | 1                        | 278.000000               | 112                   | 1                        |
| Sorted: 1            | 273.000000     | 32              | 1                  | 392.980000         | 32                  | 1                      | 175.000000               | 272                   | 1                        | 439.000000               | 112                   | 1                        |
| 10                   | 854.000000     | 320             | 3                  | 1292.000000        | 320                 | 2                      | 372.000000               | 488                   | 2                        | 771.000000               | 328                   | 3                        |
| Sorted: 10           | 869.820000     | 320             | 5                  | 1266.160000        | 320                 | 1                      | 122.000000               | 488                   | 1                        | 257.000000               | 328                   | 1                        |
| 25                   | 901.000000     | 800             | 4                  | 2445.000000        | 800                 | 3                      | 264.000000               | 928                   | 5                        | 511.000000               | 832                   | 3                        |
| Sorted: 25           | 3152.420000    | 800             | 13                 | 2396.100000        | 800                 | 3                      | 155.000000               | 928                   | 1                        | 258.000000               | 832                   | 1                        |
| 50                   | 1111.000000    | 1600            | 6                  | 5128.000000        | 1600                | 3                      | 314.000000               | 1736                  | 16                       | 536.000000               | 1576                  | 3                        |
| Sorted: 50           | 7793.850000    | 1600            | 25                 | 5025.440000        | 1600                | 3                      | 153.000000               | 1736                  | 2                        | 380.000000               | 1576                  | 1                        |
| 100                  | 1610.000000    | 3200            | 7                  | 9721.000000        | 3200                | 4                      | 320.000000               | 3656                  | 9                        | 745.000000               | 3256                  | 4                        |
| Sorted: 100          | 33335.130000   | 3200            | 50                 | 9526.580000        | 3200                | 2                      | 245.000000               | 3656                  | 1                        | 383.000000               | 3256                  | 1                        |
| 250                  | 3505.000000    | 8000            | 9                  | 27292.000000       | 8000                | 6                      | 471.000000               | 8776                  | 18                       | 889.000000               | 8008                  | 5                        |
| Sorted: 250          | 134638.560000  | 8000            | 125                | 26746.160000       | 8000                | 3                      | 208.000000               | 8776                  | 1                        | 380.000000               | 8008                  | 1                        |
| 500                  | 4973.000000    | 16000           | 11                 | 45957.000000       | 16000               | 7                      | 377.000000               | 17864                 | 18                       | 777.000000               | 16552                 | 4                        |
| Sorted: 500          | 479064.600000  | 16000           | 250                | 45037.860000       | 16000               | 3                      | 216.000000               | 17864                 | 1                        | 405.000000               | 16552                 | 1                        |

# Вывод

При использовании обычных несбалансированных деревьев, несмотря на наибольшую скорость инициализации, возникает проблема доступа к элементам при несбалансированности дерева.
Так в заданных примерах в худшем случае приходится сравнивать все элементы дерева для поиска необходимого. AVL дерево помогает решить эту проблему, сокращая общее 
количество сравнений и не требуя дополнительных расходов по памяти. Однако при удалении и добавлении элементов требуется производить балансировку, что требует определенных затратов по времени
по сравнению с бинарными. Подобная проблема отсутствует в хеш-таблицах, в котором изменение структуры требуется только для добавления элементов. В хеш-таблицах требуется меньше всего сравнений 
из-за специфики хранения ключей, но они требуют больше всего памяти. Кроме того на скорость обработки хеш-таблицы будет влиять необходимость реструктуризации при добавлении 
значений и количество коллизий, определяемое хеш-функциями. При сравнении двух реализаций хэжш-таблицы заметно, что при закрытой адресации требуется меньше памяти, так как хранятся
только необходимые значения, но из-за временной сложности доступа к элементам списка, она уступает по времени открытой адресации, где скорость доступа быстрее но требуется больше памяти. 
Однако разность производительности между этими двумя методами не такая большая, по сравнению с использованием деревьев.

# Ответ на контрольные вопросы

1.Чем отличается идеально сбалансированное дерево от AVL-дерева?

Идеально сбалансированное дерево (Perfectly Balanced Tree): Дерево, в котором число вершин у правого и левого поддерева отличается 
не блоее, чем на единицу. Узлы придобавлении располагаются равномерно слева и справа. Однако при построении такого дерева не
учитывается значение узла, поэтому такое дерево не является двоичным деревом поиска

AVL-дерево: Это форма сбалансированного дерева двоичного поиска, в котором разница в высоте между левым и правым поддеревьями для каждого узла ограничена (высота различается не более чем на 1). Это обеспечивает быстрое выполнение операций вставки, удаления и поиска.

2. Чем отличается поиск в AVL-дереве от поиска в дереве двоичного поиска?

В AVL-дереве поиск выполняется так же, как и в обычном дереве двоичного поиска. Разница заключается в том, что AVL-дерево в 
среднем требует меньше сравнений, так как дерево двоичного поиска может быть вырожденным, что в свою очередь значительно снизит
скорость поиска крайних элементов

3. Что такое хеш-таблица, каков принцип принцип построения?

Хеш-таблица это структура данных, позволяющая эффективно выполнять операции вставки, удаления и поиска. Она использует хеш-функцию для
преобразования ключа в индекс массива, где хранятся значения. Принцип 
построения:
- Выбор хеш-функции.
- Выделение массива определенного размера.
- Разрешение коллизий (в случае, если два ключа хешируются в один и
тот же индекс).

4. Что такое коллизии? Каковы методы их устранения?

Коллизии возникают, когда два различных ключа хешируются в один итот же индекс. Методы разрешения коллизий включают:
Цепочки: Каждый индекс массива представляет собой связанный список.
Открытое хеширование: При коллизии производится поиск следующего свободного слота в массиве.
Двойное хеширование: Используются две хеш-функции для определения следующего индекса при коллизии.

5. В каком случае поиск в хеш-таблицах становится неэффективен?

Поиск в хеш-таблицах становится неэффективным при большом количестве коллизий, что может привести к увеличению длины цепочек или увеличению размера открытого адреса.

6. Эффективность поиска в АВЛ деревьях, в дереве двоичного поиска, в хеш-таблицах и файле

В AVL-деревьях и деревьях двоичного поиска поиск выполняется за время, пропорциональное логарифму числа элементов в дереве.
В хеш-таблицах, при эффективном хешировании, поиск может быть выполнен за постоянное время O(1).
В файлах эффективность поиска зависит от типа файла (например, последовательный доступ, индексированный доступ) и размера данных.