# Описание условий задачи

Создать программу работы с очередью, выполняющую операции добавления, удаления элементов
и вывод текущего состояния очереди. Реализовать очередь: 
а) статическим массивом 
б) динамическим массивом 
в) списком
Все стандартные операции со очередью должны быть оформлены подпрограммами. При реализации
очереди списком в вывод текущего состояния очереди добавить просмотр адресов элементов. 
Реализовать с помощью очереди систему массового обслуживания.
Система массового обслуживания состоит из обслуживающего аппарата(ОА) и очереди заявок.
Заявки поступают в "хвост" очереди по случайному закону с интервалом
времени Т1, равномерно распределенным от 0 до 6 единиц времени (е.в.). В
ОА они поступают из "головы" очереди по одной и обслуживаются также
равновероятно за время Т2 от 0 до 1 е.в., Каждая заявка после ОА с
вероятностью Р=0.8 вновь поступает в "хвост" очереди, совершая новый цикл
обслуживания, а с вероятностью 1-Р покидает систему. (Все времена –
вещественного типа). В начале процесса в системе заявок нет.
Смоделировать процесс обслуживания до ухода из системы первых 1000
заявок. Выдавать после обслуживания каждых 100 заявок информацию о
текущей и средней длине очереди. В конце процесса выдать общее время
моделирования и количество вошедших в систему и вышедших из нее заявок,
среднее время пребывания заявки в очереди, время простоя аппарата,
количество срабатываний ОА. Обеспечить по требованию пользователя выдачу
на экран адресов элементов очереди при удалении и добавлении элементов.
Проследить, возникает ли при этом фрагментация памяти.
Процент расхождения расчетного времени и получившегося при
работе программы должен быть не больше 2-3%


# Описание ТЗ

## Описание входных данных

На вход программе подается выбранная команда - число от 0 до 14(см. Общий алгоритм данных)
Пользователь может либо добавить число, удалить число, вывести текущее состояние очереди и запустить симуляцию системы массового обслуживания для 3 реализаций списка соответственно, вывести список доступных опций, произвести замер производительности для различных реализаций очереди или выйти из программы

В зависимости от требуемой опции, программа потребует ввести данные:

- В случае добавления числа в очередь, пользователь должен ввести добавляемый символ, который может храниться в типе данных double
- В случае симуляции пользователь должен ввести команду: работа с данными по умлочанию ("1") или ввод данных самостоятельно("2"). При самостоятельном вводе данных необходимо ввести диапазон генерации: два числа в формате "Начальное значение"-"конечное значение", при этом значения доолжны быть положительными, а "Начальное значение" должно быть больше конечного. Также потребуется вывести вероятность отправки заявки в конец - дробное число от нуля до 0.97.


## Описание результирующих данных

Пользователю выдается сообщение об успехе/ошибке при выполнения требуемого действия

- При замере производительности пользователю выводится таблица времени и используемой памяти для трех реализаций очереди
- При выводе состояния очереди выводится длина очереди и ее элементы, в случае списка также выводятся список освобожденных адресов
- При выполнении симуляции выводятся общее время моделирования и количество вошедших в систему и вышедших из нее заявок,
среднее время пребывания заявки в очереди, время простоя аппарата,время простоя, количество срабатываний ОА.

## Описание задачи,реализуемой в программе 

Создание интерфейса для работы с различными реализациями очередей, сравнение эффективности использования очередей, реализованных с помощью статического массива, динамического массива, списка, определяется зависимость.Сравнительный анализ реализации
алгоритмов включения и исключения элементов из очереди при использовании трех указанных структур данных.

## Описание способов обращения к программе

Способ обращения к программе пользователем происходит через исполняемый файл app.exe.

## Описание аварийных ситуаций

- ERROR_MALLOC - ошибка выделения динамической памяти, программа не смогла выделить динамическую память на очередь
- ERROR_EMPTY - ошибка удалення из очереди, программа пытается удалить элемент из пустой очереди
- ERROR_INPUT - ошибка ввода, программа не смогла считать значение числа
- ERROR_INTERVAL - ошибка ввода интервала, формат диапазона был введен в неправильном формате
- ERROR_VALUE - ошибка значения, введеное значение не соответствует допустимым
- ERROR_QUEUE_OVERFLOW - ошибка переполнения очереди, программа не смогла добавить элемент в очередь, уже достигнут максимально допустимый размер очереди
- Другие ошибки и исключительные ситуации, связанные с операционной системой или другими программами


# Описание внутренних СД

В программме для хранения матриц используются пять структурных типов данных: 

1)static_queue_t - структурная переменная для хранения очереди, реализованной статическим массивом
```c
typedef struct
{
    double array[MAX_LEN];
    size_t begin;
    size_t end;
    size_t size;
}static_queue_t;
```
- *array - массив чисел типа double для хранения элементов очереди, размер - MAX_LEN(в программе установлен на 10000)
- begin - индекс первого элемента в очереди, хранится в виде целого беззнакового числа
- end - индекс последнего элемента в очереди, хранится в виде целого беззнакового числа
- size - количество элементов в очереди, хранится в виде целого беззнакового числа

2)dynamic_queue_t - структурная переменная для хранения очереди, реализованной динамическим массивом
```c
typedef struct
{
    double *array;
    size_t begin;
    size_t end;
    size_t size;
    size_t allocated_memory;
}
dynamic_queue_t
```
- *array - массив чисел типа double для хранения элементов очереди, размер - MAX_LEN(в программе установлен на 10000)
- begin - индекс первого элемента в очереди, хранится в виде целого беззнакового числа
- end - индекс последнего элемента в очереди, хранится в виде целого беззнакового числа
- size - количество элементов в очереди, хранится в виде целого беззнакового числа
- allocated_memory - количество значений, на которые выделена память программой, если количество элементов в очереди совпадает с allocated_memory - осуществляется перевыделение паяти, новый участок памяти, новый участок в два раза больше старого, хранится в виде целого беззнакового числа


3)Node - структурная переменная для хранения элемента односвязного списка
```c 
typedef struct Node
{
    double value;
    struct Node *next;
}Node;
```
- value - тип данных double, хранящий текущий элемент
- *next - указатель на следующий элемент очереди


4)list_queue_t - структурная переменная для хранения очереди, реализованного односвязным списком
```c 
typedef struct
{
    Node *head;
    Node *tail;
    size_t size;
    size_t allocated;
}list_queue_t;
```
- *head - указатель на голову очереди
- *tail - указатель на хвост очереди
- size - количество элементов в очереди, хранится в виде целого беззнакового числа
- allocated - количество значений, на которое было выделено памяти в течение всего времени существования объекта, хранится в виде целого беззнакового числа


5)freed_adress_t - структурная переменная для хранения операций над областями памяти
```c 
typedef struct freed_adress_t
{
    Node* adress;
    char operation;
    size_t size;
    struct freed_adress_t* next;
}freed_adress_t;
```
- *adress - адресс освобожденной области, хранится в виде указателя на Node
- operation - тип операции, может быть либо "-" либо "+", хранится в виде char
- size - размер освобожденной области , хранится в виде целого беззнакового числа
- *next - указатель на следующую свободную область памяти

# Описание алгоритмов

## Общий алгоритм данных

1. Начинается выполнение программы в функции main. Пользователю предлагается выбрать дальнейшее действие:
- СТАТИЧЕСКИЙ МАССИВ: 

        -1  - Добавить число в очередь 
        -2  - Удалить число из очереди 
        -3  - Вывести состояние очереди 
        -4  - Запустить симуляцию 
- ДИНАМИЧЕСКИЙ МАССИВ: 

        -5  - Добавить число в очередь 
        -6  - Удалить число из очереди 
        -7  - Вывести состояние очереди 
        -8  - Запустить симуляцию 
-СПИСОК: 

        -9  - Добавить число в очередь 
        -10 - Удалить число из очереди 
        -11 - Вывести состояние очереди 
        -12 - Запустить симуляцию 
-13 - Замер производительности 

-14 - Вывод доступных опций 

-0 - Завершение работы..... 

В случаем ошибки ввода опции, пользователю предложится ввести опцию заново. 
При выборе опции "0" программа завершает свою работу

###  Добавление символа в статическую очередь
- На вход подается указатель на очередь, куда требуется добавить элемент и сам элемент
- На выход возвращается код возврата 0, если элемент успешно добавлен и ERROR_QUEUE_OVERFLOW, если произошла ошибка
- Проверяется размер очереди, если размер превышен - возвращается ошибка
- В массив на позицию "(индекс конца очереди - 1) % MAX_LEN" добаляется элемент
- Индекс конца очереди увеличивается на единицу

###  Удаление символа из статической очереди 
- На вход подается указатель на очередь, откуда требуется удалить элемент 
- Возвращается удаленный элемент или NAN, если очередь пуста
- Проверяется размер очереди, если размер 0 - возвращается NAN
- Считывается элемент из "удаленной" позиции
- Уменьшается размер очереди на единицу
- Индекс начала очереди увеличивается на единицу

###  Добавление символа в динамической очереди

- На вход подается указатель на очередь, куда требуется добавить элемент и сам элемент
- На выход возвращается код возврата 0, если элемент успешно добавлен или код ошибки, если произошла ошибка
- Проверяется размер выделенной памяти, если она превышает необходимый - очередь расширяется в два раза
- Если очередь не удалось расширить - возвращается ошибка
- В массив на позицию "(индекс конца очереди - 1) % MAX_LEN" добаляется элемент
- Индекс конца очереди увеличивается на единицу

###  Удаление символа из динамической очереди 

- На вход подается указатель на очередь, откуда требуется удалить элемент 
- Возвращается удаленный элемент или NAN, если очередь пуста
- Проверяется размер очереди, если размер 0 - возвращается NAN
- Считывается элемент из "удаленной" позиции
- Уменьшается размер очереди на единицу
- Индекс начала очереди увеличивается на единицу

###  Добавление символа в очередь-список

- На вход подается указатель на очередь, куда требуется добавить элемент и сам элемент
- На выход возвращается код возврата 0, если элемент успешно добавлен или код ошибки, если произошла ошибка
- Создается новый объект
- Если не удалось выделить память на создаваемый объект - возвращается ошибка
- Указатель на хвост очереди устанавливается на добавляемый элемент
- Увеличивается размер очереди на единицу


###  Удаление символа из очереди-списка

- На вход подается указатель на очередь, откуда требуется удалить элемент 
- Возвращается удаленный элемент или NAN, если очередь пуста
- Проверяется указатель на вершину очереди, если указатель равен NULL - возвращается NAN
- Создается новый временный объект для хранения значения
- Указатель на вершину очереди смещается на следующий элемент, если такой есть
- Освобожденный элемент записывается в список овобожденных адресов
- Освобождается память под удаляемый объект
- Уменьшается размер очереди на единицу

###  Симуляция очереди 

- Пользователю предлагается либо провести симуляцию с параметрами по умолчанию, либо ввести собственные
- В случае неправильного ввода параметров, симуляция заканчивается
- Вычисляются ожидаемое время симулации
- Инициализируется очередь выбранного типа
- Основно цикл симуляции 
    - Если время поступления следующей заявки меньше или равно времени обслуживания, то добавляем заявку в очередь.
     - Если очередь пуста, то обновляем время обслуживания.
     - Если очередь не пуста, то обрабатываем первую заявку из очереди:
       - Проверяем вероятность возврата
       - Если заявка возвращается, то заносим её обратно в очередь
       - Увеличиваем время обслуживания
       - Выводим статистику обработки каждые `PRINT_REQ`
- Осуществляется вывод информации полученной во время симуляции и сравнивается с теоретическими значениями

# Тестирование


## Положительные тесты

|                                  Описание тестов                                  |                        Ожидаемый результат                         |
| :-------------------------------------------------------------------------------: | :----------------------------------------------------------------: |
|               Добавление элемента 12  в очередь  на основе массива                |                         Добавление успешно                         |
|            Добавление элемента 12  в пустую очередь на основе массива             |                         Добавление успешно                         |
|             Удаление элемента из не пустой очередь на основе массива              |                          Удаление успешно                          |
|                Вывод текущего состояния очередь на основе массива                 |                 Вывод длины стека и его элементов                  |
|                Добавление элемента 12  в очередь  на основе списка                |                         Добавление успешно                         |
|             Добавление элемента 12  в пустую очередь на основе списка             |                         Добавление успешно                         |
|              Удаление элемента из не пустой очереди на основе списка              |                          Удаление успешно                          |
|                 Вывод текущего состояния очереди на основе списка                 |                 Вывод длины стека и его элементов                  |
| Вывод текущего состояния очереди на основе массива, из очереди удалялись элементы | Вывод длины стека и его элементов, вывод особожденных ячеек памяти |
|                   Запуск симуляции для параметров по умолчанию                    |          Вывод теоретических и реальных данных симуляции           |
|                    Запуск симуляции для параметров 0-1 0-1 0.4                    |          Вывод теоретических и реальных данных симуляции           |




## Негативные тесты
|                      Описание тестов                       | Ожидаемый код ошибки |
| :--------------------------------------------------------: | :------------------: |
|    Попытка удаления из пустой очереди на основе массива    |     ERROR_EMPTY      |
|    Попытка удаления из пустой очередь на основе списка     |     ERROR_EMPTY      |
| Превышение максимального размера очереди на основе массива | ERROR_STACK_OVERFLOW |
|        Попытка выделения памяти, вся память занята         |     ERROR_MALLOC     |
|                Вместо числа введена строка                 |     ERROR_INPUT      |
|             Вместо числа введена пустая строка             |     ERROR_INPUT      |
|              Вместо интервала введена строка               |     ERROR_INPUT      |
|            Формат введен в неправильном формате            |    ERROR_INTERVAL    |
|   Время начала промежутка генерации больше времени конца   |     ERROR_VALUE      |
|                 Вероятность больше единицы                 |     ERROR_VALUE      |
|                  Вероятность меньше нуля                   | ERROR_VALUE |



# Оценка эффективности

### Оценка эффективности на добавление и удаление элементов

| Количество элементов очереди | Память (static), байты | Время (static), нс | Память (dynamic), байты | Время (dynamic), нс | Память (list), байты | Время (list), нс |
| ---------------------------- | ---------------------- | ------------------ | ----------------------- | ------------------- | -------------------- | ---------------- |
| 1                            | 80000                  | 63.000000          | 16                      | 137.000000          | 16                   | 402.000000       |
| 10                           | 80000                  | 318.000000         | 128                     | 972.000000          | 160                  | 3140.000000      |
| 25                           | 80000                  | 754.000000         | 256                     | 1481.000000         | 400                  | 7699.000000      |
| 50                           | 80000                  | 1609.000000        | 512                     | 2295.000000         | 800                  | 15936.000000     |
| 100                          | 80000                  | 2997.000000        | 1024                    | 3691.000000         | 1600                 | 30863.000000     |
| 250                          | 80000                  | 7201.000000        | 2048                    | 7643.000000         | 4000                 | 59894.000000     |
| 500                          | 80000                  | 14048.000000       | 4096                    | 12620.000000        | 8000                 | 110131.000000    |
| 1000                         | 80000                  | 28275.000000       | 8192                    | 15044.000000        | 16000                | 144145.000000    |
| 5000                         | 80000                  | 101582.000000      | 65536                   | 99217.000000        | 80000                | 550384.000000    |

### Оценка эффективности для очереди реализацией на статическом массиве и списке

Найдем эффективность обработки элементов очереди в %, используя формулу:

Эффективность = (100-(100* Время выполнения статического / Время выполнения списка))

| Количество элементов очереди | Эффективность, % |
| :--------------------------- | :---------------: |
| 1                            |    86,64606727   |
| 10                           |    83,78628787   |
| 25                           |    80,99210483   |
| 50                           |    91,35450474   |
| 100                          |    91,42974315   |
| 250                          |    91,74220843   |
| 500                          |    91,54534862   |
| 1000                         |    91,94012853   |
| 5000                         |    89,30769973   |

### Симуляция на 1000 элементах при времени поступления 0-6, обработки 0-1, вероятности возврата в конец 0.8:
- Статический массив:  67133.000000, максимально занимаемая память - 80000
- Динамический массив: 117483.000000, максимально занимаемая память - 128
- Список:              356279.000000, максимально занимаемая память - 160

### Симуляция на 1000 элементах при времени поступления 3-7, обработки 3-7, вероятности возврата в конец 0.1:
- Статический массив:  18189.000000, максимально занимаемая память - 80000
- Динамический массив: 31831.000000, максимально занимаемая память - 32
- Список:              84406.000000, максимально занимаемая память - 32

### Симуляция на 1000 элементах при времени поступления 0-1, обработки 0-6, вероятности возврата в конец 0.5:
- Статический массив:  73696.000000, максимально занимаемая память - 80000
- Динамический массив: 128968.000000, максимально занимаемая память - 65536
- Список:              529137.000000, максимально занимаемая память - 75936


### Анализ фрагментации памяти

Операция:+ Адрес 0x7f8af65040a0:размер  16 байт 
Операция:+ Адрес 0x7f8af614ce60:размер  16 байт 
Операция:+ Адрес 0x7f8af6404080:размер  16 байт 
Операция:+ Адрес 0x7f8af63040a0:размер  16 байт 
Операция:+ Адрес 0x7f8af614ce30:размер  16 байт 
Операция:+ Адрес 0x7f8af4f05ef0:размер  16 байт 
Операция:+ Адрес 0x7f8af614ce00:размер  16 байт 
Операция:+ Адрес 0x7f8af651d4c0:размер  16 байт 
Операция:+ Адрес 0x7f8af61fffd0:размер  16 байт 
Операция:+ Адрес 0x7f8af66040a0:размер  16 байт 

Операция:- Адрес 0x7f8af65040a0:размер  16 байт 
Операция:- Адрес 0x7f8af614ce60:размер  16 байт 
Операция:- Адрес 0x7f8af6404080:размер  16 байт 
Операция:- Адрес 0x7f8af63040a0:размер  16 байт 
Операция:- Адрес 0x7f8af614ce30:размер  16 байт 
Операция:- Адрес 0x7f8af4f05ef0:размер  16 байт 
Операция:- Адрес 0x7f8af614ce00:размер  16 байт 
Операция:- Адрес 0x7f8af651d4c0:размер  16 байт 
Операция:- Адрес 0x7f8af61fffd0:размер  16 байт 
Операция:- Адрес 0x7f8af66040a0:размер  16 байт 

Операция:+ Адрес 0x7f8af65040a0:размер  16 байт 
Операция:+ Адрес 0x7f8af614ce60:размер  16 байт 
Операция:+ Адрес 0x7f8af6404080:размер  16 байт 
Операция:+ Адрес 0x7f8af63040a0:размер  16 байт 
Операция:+ Адрес 0x7f8af614ce30:размер  16 байт 
Операция:+ Адрес 0x7f8af4f05ef0:размер  16 байт 
Операция:+ Адрес 0x7f8af614ce00:размер  16 байт 
Операция:+ Адрес 0x7f8af651d4c0:размер  16 байт 
Операция:+ Адрес 0x7f8af61fffd0:размер  16 байт 
Операция:+ Адрес 0x7f8af66040a0:размер  16 байт 


При анализе памяти, выделяемой на очередь реализованный с помощью списка, память на новый элемент может выделится на ранее 
освобожденном месте в памяти, при использовании этих алгоритмов фрагментация памяти не происходит. 

# Вывод

По сравнению с очередями, основывающимися на статических и динамических массивах, очередь в виде односвязного списка менее эффективен по времени. Обращение по индексу в массивах осуществляется быстрее, чем доступ по указателям в случае односвязного списка. Однако использование очереди на основе статического массива имеет проблемы в виде заранее ограниченного количества элементов, так как стек памяти сильно ограничен, по сравнению с кучей.Кроме того, при небольшом размере очереди список будет эффективнее, так как в памяти находятся только используемые значения. При использовании очереди на 
динамическом массиве решается проблема ограниченного числа элементов, однако при использовании динамической памяти потребуется дополнительно перевыделять память в случае превышения буфера, что в худшем случае осуществляется медленнее чем выделение на связном списке.
Поэтому связанный список будет более эффективным, если количество выделенной памяти/элеметов в очереди не известно заранее.


# Ответ на контрольные вопросы

1.Что такое FIFO и LIFO?
Очередь – это последовательный список переменной длины, включение элементов в который идет с одной стороны (с «хвоста»), а исключение – с другой
стороны (с «головы»). Принцип работы очереди: первым пришел – первым вышел, т.е. First In – First Out (FIFO).
Стек – это последовательный список с переменной длиной, в котором включение и исключение элементов происходит только с одной стороны – с его
вершины. Стек функционирует по принципу: последним пришел – первым ушел, Last In – First Out (LIFO).
2. Каким образом, и какой объем памяти выделяется под хранение очереди при различной ее реализации?
Реализация очереди в виде массива. 
При моделировании простейшей линейной очереди на основе одномерного массива выделяется последовательная область памяти из m мест по L байт, 
где L – размер поля данных для одного элемента размещаемого типа. В каждый текущий момент времени выделенная память может
быть вся свободна, занята частично или занята полностью.
Реализация очереди в виде линейного списка. 
В этом случае в статической памяти можно либо хранить адрес начала и конца очереди, либо – адрес начала очереди и количество элементов.
3. Каким образом освобождается память при удалении элемента из очереди приее различной реализации?
В реализации с динамическим массивом: при удалении элемента из очереди, выделенная под негопамять освобождается с использованием операции free. 
Важно обеспечить правильное управление индексами (Pin) и (Pout), чтобы избежать утечек памяти и корректно освободить выделенные ресурсы.
В реализации с использованием списка: при удалении элемента из списка, освобождается память,
выделенная под сам элемент задачи, а также под узел списка. Освобождение памяти
производится с использованием операции free.
4.Что происходит с элементами очереди при ее просмотре?
При просмотре элементов очереди массивом: происходит доступ к элементам массива поиндексу, начиная с индекса Pout и заканчивая индексом Pin. 
Элементы при этом не удаляются из массива.
При просмотре элементов очереди списком: происходит перемещение по узлам списка с использованием указателей. Элементы не удаляются из списка в процессе просмотра.
5.От чего зависит эффективность физической реализации очереди?
Эффективность физической реализации очереди зависит от:
Частоты операций вставки и удаления: 
если операции вставки и удаления выполняются с примерно равной частотой, то реализация с использованием списка может быть эффективнее, так
как добавление и удаление элементов в середине списка занимает постоянное время.
Объема данных: 
для больших объемов данных реализация с использованием массива может быть эффективнее из-за лучшей локальности данных и меньшего числа указателей.
6. Каковы достоинства и недостатки различных реализаций очереди в зависимости от выполняемых над ней операций?
Очередь статическим массивом:
Достоинства: Простота реализации, хорошая локальность данных. 
Недостатки: Фиксированный размер, что может привести к переполнению или избыточной памяти.
Очередь динамическим массивом:
Достоинства: Динамический размер, хорошая локальность данных. 
Недостатки: Большие затраты при расширении/сжатии при перевыделении памяти
Очередь списком:
Достоинства: Динамический размер, удобство вставки и удаления в середине очереди.
Недостатки: больше затраты памяти на хранение указателей, возможны фрагментация памяти.
7. Что такое фрагментация памяти, и в какой части ОП она возникает?
В процессе моделирования очереди может оказаться, что при последовательных запросах на выделение и освобождении памяти под очередной элемент выделяется не та память, 
которая была только что освобождена при удалении элемента. Участки свободной и занятой памяти могут чередоваться, т.е. может возникнуть фрагментация памяти.
8. Для чего нужен алгоритм «близнецов».
Алгоритм "близнецов" используется в симуляции с двумя очередями. Он предполагает, что при появлении нового элемента, необходимо решить, в какую из двух очередей его поместить. Если одна из очередей короткая, новый элемент помещается в эту очередь, иначе выбирается случайная очередь.
 Такой подход позволяет достичь баланса между двумя очередями и равномерно распределить элементы между ними.
9. Какие дисциплины выделения памяти вы знаете?
First Fit (Первый Подходящий): выделяет первый блок памяти, который подходит по размеру.
Best Fit (Лучший Подходящий): выделяет блок памяти, который наилучшим образом соответствует размеру запроса, минимизируя фрагментацию.
Worst Fit (Худший Подходящий): выделяет самый большой из доступных блоков памяти, что может привести к уменьшению количества оставшейся свободной памяти.
Next Fit (Следующий Подходящий): аналогичен First Fit, но начинает поиск с того места, где закончил предыдущий запрос.
Quick Fit (Быстрый Подходящий): использует несколько списков фиксированных размеров для быстрого доступа к блокам нужного размера.
Алгоритм "близнецов" (Twin Allocation).
10. На что необходимо обратить внимание при тестировании программы?
- Рассогласование между средними ожидаемыми временами и временами, полученными в моделирующей программе должно быть не больше 2–3%.
- Необходимо проверить правильность работы программы при различном заполнении очередей, т.е., когда время моделирования определяется временем обработки заявок и
когда определяется временем прихода заявок;
- Отследить переполнение очереди, если очередь в программе ограничена.
- При реализации очереди списком необходимо тщательно следить за освобождением памяти при удалении элемента из очереди.
- Следует проверять, происходит ли при этом фрагментация памяти.
11. Каким образом физически выделяется и освобождается память при динамических запросах?
Выделение памяти:
При динамическом запросе памяти используется функция malloc, calloс. Когда программа вызывает одну из этих функций, операционная система выделяет участок памяти нужного
размера. Эта память может быть неинициализированной (malloc) или проинициализированной нулями (calloc).
Освобождение памяти:
Для освобождения динамически выделенной памяти используется функция free. Когда программа вызывает free для указателя, который ранее был возвращен malloc или calloc,
операционная система помечает соответствующий блок памяти как свободный.
