# Описание условий задачи

Создать программу работы со стеком, выполняющую операции добавления, удаления элементов
и вывод текущего состояния стека. Реализовать стек: 
а) статическим массивом 
б) динамическим массивом 
в) списком
Все стандартные операции со стеком должны быть оформлены подпрограммами. При реализации
стека списком в вывод текущего состояния стека добавить просмотр адресов элементов. 
Используя стек, определить, является ли строка
палиндромом

# Описание ТЗ

## Описание входных данных

На вход программе подается выбранная команда - число от 0 до 14(см. Общий алгоритм данных)
Пользователь может либо добавить символ, удалить символ, вывести текущее состояние стека и проверить слово на палиндром для 3 реализаций списка
соответственно, вывести список доступных опций, произвести замер производительности для различных реализаций стека или выйти из программы

В зависимости от требуемой опции, программа потребует ввести данные:

- В случае добавления символа в стек, пользователь должен ввести добавляемый символ, который может храниться в типе данных char и поддерживаться кодировкой компьютера
- В случае проверки строки, требуется ввести строку, строка не должна превышать буфер в 10000 символов


## Описание результирующих данных

Пользователю выдается сообщение об успехе/ошибке при выполнения требуемого действия

- При замере производительности пользователю выводится таблица времени и используемой памяти для трех реализаций стека
- При выводе состояния стека выводится длина стека и его элементы, в случае списка также выводятся список освобожденных адресов
- При проверке слова на палиндром выводится сообщение, является ли слово палиндромом или нет

## Описание задачи,реализуемой в программе 

Создание интерфейса для работы с различными реализациями списков, сравнение эффективности использования список, реализованных с помощью статического массива, динамического массива, списка, определяется зависимость времени проверки слова на палиндром от длины строки и реализации стека

## Описание способов обращения к программе

Способ обращения к программе пользователем происходит через исполняемый файл app.exe.

## Описание аварийных ситуаций

- ERROR_MALLOC - ошибка выделения динамической памяти, программа не смогла выделить динамическую память на стек
- ERROR_STR_INPUT - ошибка ввода строки, программа не смогла считать строки
- ERROR_EMPTY - ошибка удаленния из стека, программа пытается удалить элемент из пустого стека
- ERROR_EMPTY_STR - ошибка пустой строки, программе на вход была передана пустая строка, нельзя проверить строку на палиндром
- ERROR_STACK_OVERFLOW - ошибка переполнения стека, программа не смогла добавить элемент в стек, уже достигнут максимально допустимый размер стека
- ERROR_STR_SIZE - ошибка размера строки, строка превышает размер буфера
- Другие ошибки и исключительные ситуации, связанные с операционной системой или другими программами


# Описание внутренних СД

В программме для хранения матриц используются пять структурных типов данных: 

1)static_stack_t - структурная переменная для хранения стека, реализованного статическим массивом
```c
typedef struct
{
    char array[MAX_LEN];
    size_t index_cur;
}
static_stack_t;
```
- array - массив символов для хранения элементов стека, размер - MAX_LEN(в программе установлен на 10000), первый элемент стека всегда хранится в массиве под нулевым индексом
- index_cur - индекс следующего за последним элементом в стеке, длина стека, хранится в виде целого беззнакового числа

2)dynamic_stack_t - структурная переменная для хранения стека, реализованного динамическим массивом
```c
typedef struct
{
    char *array;
    size_t index_cur;
    size_t allocated_memory;
}
dynamic_stack_t;
```
- *array - значения элементов стека, длина равна количеству ненулевых элементов,элемент - символ(тип char) память выделяется динамически
- index_cur - размер стека, хранится в виде целого беззнакового числа
- allocated_memory - количество значений, на которые выделена память программой, если количество элементов в стеке совпадает с allocated_memory - осуществляется перевыделение паяти, новый участок памяти, новый участок в два раза больше старого, хранится в виде целого беззнакового числа

3)Node - структурная переменная для хранения элемента односвязного списка
```c 
typedef struct Node
{
    char value;
    struct Node *next;
}Node;
```
- value - целочисленный тип данных char, хранящий текущий символ
- *next - указатель на следующий элемент стека


4)list_stack_t - структурная переменная для хранения стека, реализованного односвязным списком
```c 
typedef struct
{
    Node *head;
    size_t size;
    size_t allocated;
}list_stack_t;
```
- *head - указатель на вершину стека(последний добавленный элемент)
- size - размер стека , хранится в виде целого беззнакового числа
- allocated - количество значений, на которое было выделено памяти в течение всего времени существования объекта, хранится в виде целого беззнакового числа


5)freed_adress_t - структурная переменная для хранения освобожденных областей
```c 
typedef struct freed_adress_t
{
    char* adress;
    size_t size;
    struct freed_adress_t* next;
}freed_adress_t;
```
- *adress - адресс освобожденной области, хранится в виде указателя на char
- size - размер освобожденной области , хранится в виде целого беззнакового числа
- *next - указатель на следующую свободную область памяти

# Описание алгоритмов

## Общий алгоритм данных

1. Начинается выполнение программы в функции main. Пользователю предлагается выбрать дальнейшее действие:
- СТАТИЧЕСКИЙ МАССИВ: 
        - 1 - Добавить символ в статический стек 
        - 2 - Удалить символ из статического стека 
        - 3 - Вывести состояние стека 
        - 4 - Проверка введеной строки на палиндром с помощью стека 
- ДИНАМИЧЕСКИЙ МАССИВ: 
        - 5 - Добавить символ в стек 
        - 6 - Удалить символ из стека 
        - 7 - Вывести состояние стека 
        - 8 - Проверка введеной строки на палиндром с помощью стека 
- СПИСОК: 
        - 9  - Добавить символ в стек 
        - 10 - Удалить символ из стека 
        - 11 - Вывести состояние стека 
        - 12 - Проверка введеной строки на палиндром с помощью стека 
- 13 - Замер производительности 
- 14 - Вывод доступных опций 
- 0 - Завершение работы..... 
В случаем ошибки ввода опции, пользователю предложится ввести опцию заново. 
При выборе опции "0" программа завершает свою работу

###  Добавление символа в статический стек
- На вход подается указатель на список, куда требуется добавить элемент и сам элемент
- На выход возвращается код возврата 0, если элемент успешно добавлен и -1, если произошла ошибка
- Проверяется размер стека, если размер превышен - возвращается ошибка
- В массив на позицию "длина стека - 1" добаляется элемент

###  Удаление символа из статического стека 
- На вход подается указатель на список, откуда требуется удалить элемент 
- Возвращается удаленный элемент или -1, если стек пуст
- Проверяется размер стека, если размер 0 - возвращается ошибка
- Уменьшается размер стека на единицу
- Считывается элемент из "удаленной" позиции

###  Добавление символа в динамический стек

- На вход подается указатель на список, куда требуется добавить элемент и сам элемент
- На выход возвращается код возврата 0, если элемент успешно добавлен и -1, если произошла ошибка
- Проверяется размер выделенной памяти, если она превышает необходимый - стек расширяется в два раза
- Если стек не удалось расширить - возвращается ошибка
- В массив на позицию "длина стека - 1" добаляется элемент

###  Удаление символа из динамического стека 

- На вход подается указатель на список, откуда требуется удалить элемент 
- Возвращается удаленный элемент или -1, если стек пуст
- Проверяется размер стека, если размер 0 - возвращается ошибка
- Уменьшается размер стека на единицу
- Считывается элемент из "удаленной" позиции

###  Добавление символа в стек список

- На вход подается указатель на список, куда требуется добавить элемент и сам элемент
- На выход возвращается код возврата 0, если элемент успешно добавлен и -1, если произошла ошибка
- Создается новый объект
- Если не удалось выделить память на создаваемый объект - возвращается ошибка 
- Увеличивается размер стека на единицу
- В массив на позицию "длина стека - 1" добаляется элемент

###  Удаление символа из стека списка

- На вход подается указатель на список, откуда требуется удалить элемент 
- Возвращается удаленный элемент или -1, если стек пуст
- Создается новый временный объект для хранения значения
- Указатель на вершину стека смещается на предыдущий элемент, если такой есть
- Освобожденный элемент записывается в список овобожденных адресов
- Освобождается память под удаляемый объект

###  Проверка строки на палиндром с помощью стека 

- Возвращается 1 если слово- палиндром, 0 - если нет или код ошибки
- Осуществляется ввод слова из конслои
- Если строка пустая или превышает допустимый буфер - возвращается ошибка
- Добавляем каждый из элементов строки в стек
- Проходимся заново по строке и сравниваем символ с полученным из стека, если символы не равны - слово не палиндром


# Тестирование


## Положительные тесты

|                                Описание тестов                                 |                        Ожидаемый результат                         |
| :----------------------------------------------------------------------------: | :----------------------------------------------------------------: |
|               Добавление элемента "Q"  в стек  на основе массива               |                         Добавление успешно                         |
|            Добавление элемента "Q"  в пустой стек на основе массива            |                         Добавление успешно                         |
|            Удаление элемента из не пустого стека на основе массива             |                          Удаление успешно                          |
|                Вывод текущего состояния стека на основе массива                |                 Вывод длины стека и его элементов                  |
|               Добавление элемента "Q"  в стек  на основе списка                |                         Добавление успешно                         |
|            Добавление элемента "Q"  в пустой стек на основе списка             |                         Добавление успешно                         |
|             Удаление элемента из не пустого стека на основе списка             |                          Удаление успешно                          |
|                Вывод текущего состояния стека на основе массива                |                 Вывод длины стека и его элементов                  |
| Вывод текущего состояния стека на основе массива, из списка удалялись элементы | Вывод длины стека и его элементов, вывод особожденных ячеек памяти |



## Негативные тесты
|                     Описание тестов                      | Ожидаемый код ошибки |
| :------------------------------------------------------: | :------------------: |
|   Попытка удаления из пустого стека на основе массива    |     ERROR_EMPTY      |
|    Попытка удаления из пустого стека на основе списка    |     ERROR_EMPTY      |
| Превышение максимального размера стека на основе массива | ERROR_STACK_OVERFLOW |
|        Введена строка, превышающая размер буфера         |    ERROR_STR_SIZE    |
|       Попытка выделения памяти, вся память занята        |     ERROR_MALLOC     |
|                  Введена пустая строка                   |   ERROR_EMPTY_STR    |




# Оценка эффективности

### Оценка эффективности на добавление и удаление элементов

| Количество элементов стека | Память(static), байты | Время(static), нс | Память(dynamic), байты | Время(dynamic), нс | Память(list), байты | Время(list), нс |
| -------------------------- | --------------------- | ----------------- | ---------------------- | ------------------ | ------------------- | --------------- |
| 1                          | 5000                  | 56                | 2                      | 59                 | 16                  | 159             |
| 10                         | 5000                  | 176               | 16                     | 186                | 160                 | 871             |
| 25                         | 5000                  | 322               | 32                     | 339                | 400                 | 1772            |
| 50                         | 5000                  | 458               | 64                     | 483                | 800                 | 3103            |
| 100                        | 5000                  | 683               | 128                    | 719                | 1600                | 6034            |
| 250                        | 5000                  | 1334              | 256                    | 1405               | 4000                | 13816           |
| 500                        | 5000                  | 2507              | 512                    | 2639               | 8000                | 28345           |
| 1000                       | 5000                  | 4634              | 1024                   | 4878               | 16000               | 55858           |
| 5000                       | 5000                  | 22507             | 8192                   | 23692              | 80000               | 281246          |

### Оценка эффективности на добавление элементов

| Количество элементов стека | Память(static), байты | Время(static), нс | Память(dynamic), байты | Время(dynamic), нс | Память(list), байты | Время(list), нс |
| -------------------------- | --------------------- | ----------------- | ---------------------- | ------------------ | ------------------- | --------------- |
| 1                          | 5000                  | 22                | 2                      | 56                 | 16                  | 120             |
| 10                         | 5000                  | 60                | 16                     | 151                | 160                 | 673             |
| 25                         | 5000                  | 102               | 32                     | 255                | 400                 | 1427            |
| 50                         | 5000                  | 111               | 64                     | 279                | 800                 | 2523            |
| 100                        | 5000                  | 197               | 128                    | 493                | 1600                | 4494            |
| 250                        | 5000                  | 364               | 256                    | 910                | 4000                | 10326           |
| 500                        | 5000                  | 530               | 512                    | 1327               | 8000                | 19544           |
| 1000                       | 5000                  | 1015              | 1024                   | 2539               | 16000               | 39421           |
| 5000                       | 5000                  | 4683              | 8192                   | 11709              | 80000               | 192536          |


### Оценка эффективности для стека реализацией на статическом массиве и списке

Найдем эффективность обработки разряженной матрицы в %, используя формулу:

Эффективность = (100-(100* Время выполнения статического / Время выполнения списка))

| Количество элементов стека,% | Эффективность, % |
| :--------------------------- | :--------------: |
| 1                            |   64,74842767    |
| 10                           |   79,71297359    |
| 25                           |   81,82562077    |
| 50                           |   85,21269739    |
| 100                          |   88,67998011    |
| 250                          |   90,33909959    |
| 500                          |    91,1552302    |
| 1000                         |    91,7037846    |
| 5000                         |   91,99725507    |


### До освобождения стека размером 10

Длина стека: 10 
Элементы стека:
Элемент # 0 : A          Адрес: 0x138704150 
Элемент # 1 : A          Адрес: 0x138704140 
Элемент # 2 : A          Адрес: 0x138704130 
Элемент # 3 : A          Адрес: 0x138704120 
Элемент # 4 : A          Адрес: 0x138704110 
Элемент # 5 : A          Адрес: 0x138704100 
Элемент # 6 : A          Адрес: 0x1387040f0 
Элемент # 7 : A          Адрес: 0x1387040e0 
Элемент # 8 : A          Адрес: 0x1387040d0 
Элемент # 9 : A          Адрес: 0x1387040c0 

### После освобождения стека размером 10

Освобожденные зоны памяти: 
Адрес 0x1387040c0:размер  16 байт 
Адрес 0x1387040d0:размер  16 байт 
Адрес 0x1387040e0:размер  16 байт 
Адрес 0x1387040f0:размер  16 байт 
Адрес 0x138704100:размер  16 байт 
Адрес 0x138704110:размер  16 байт 
Адрес 0x138704120:размер  16 байт 
Адрес 0x138704130:размер  16 байт 
Адрес 0x138704140:размер  16 байт 
Адрес 0x138704150:размер  16 байт

### Дальнейшее использование освобожденной памяти для следующего стека

Длина стека: 25
Элементы стека:
Элемент # 0 : A          Адрес: 0x138704150 
Элемент # 1 : A          Адрес: 0x138704140 
Элемент # 2 : A          Адрес: 0x138704130 
Элемент # 3 : A          Адрес: 0x138704120 
Элемент # 4 : A          Адрес: 0x138704110 
Элемент # 5 : A          Адрес: 0x138704100 
Элемент # 6 : A          Адрес: 0x1387040f0 
Элемент # 7 : A          Адрес: 0x1387040e0 
Элемент # 8 : A          Адрес: 0x1387040d0 
Элемент # 9 : A          Адрес: 0x1387040c0 


При анализе памяти, выделяемой на стек реализованный с помощью списка, память на новый элемент может выделится на ранее 
освобожденном месте в памяти, при использовании этих алгоритмов фрагментация памяти не происходит. 

# Вывод

По сравнению со стеками, основывающимися на статических и динамических массивах, массив в виде односвязного списка менее эффективен по времени. Обращение по индексу в массивах осуществляется быстрее, чем доступ по указателям в случае односвязного списка. Однако использование стека на основе статического массива имеет проблемы в виде заранее ограниченного количества элементов, так как стек памяти  сильно ограничен, по сравнению с кучей.Кроме того, при небольшом размере стека список будет эффективнее, так как в памяти находятся только используемые значения. При использовании стека на 
динамическом массиве решается проблема ограниченного числа элементов, однако при использовании динамической памяти потребуется дополнительно перевыделять память в случае превышения буфера, что в худшем случае осуществляется медленнее чем выделение на связном списке.
Поэтому связанный список будет более эффективным, если количество выделенной памяти/элеметов в стеке не известно заранее. 

# Ответ на контрольные вопросы

1. Что такое стек?
Стек – это последовательный список с переменной длиной, в котором включение исключение
элементов происходит только с одной стороны – с его вершины. Стек функционирует по
принципу: последним пришел – первым ушел, Last In – First Out (LIFO).
2. Каким образом и сколько памяти выделяется под хранение стека при различной его
реализации?
Реализации стека могут быть разными, и количество выделяемой памяти зависит от конкретной
реализации. Вот несколько примеров:
Стек на основе статического массива: Память выделяется под массив фиксированного размера, который
используется для хранения элементов стека. Размер массива определяется заранее, и вся память
для стека выделяется одновременно.
Стек на основе динамического массива: Память выделяется на куче и перевыделяется по мере 
необходимости, все данные содержатся на одном участке памяти, что упрощает освобождение памяти
Стек на основе связанного списка: Здесь память выделяется динамически при добавлении
каждого элемента. Каждый элемент (узел) стека содержит указатель на следующий элемент и
значение. Таким образом, память выделяется по мере необходимости, и стек может расти
динамически.
Количество памяти, выделенной для стека, зависит от его размера и структуры данных,
используемых для его реализации.
3. Каким образом освобождается память при удалении элемента стека при различной реализации стека?
При удалении элемента из стека, освобождение памяти происходит по-разному в зависимости от реализации стека:
Стек на основе массива: При удалении элемента из массива, память не освобождается явным
образом. Просто уменьшается указатель (индекс) на вершину стека. Это позволяет заменить
старое значение новым при следующем добавлении элемента. При завершении программы освобождается весь блок памяти, на  котором хранится стек. 
Стек на основе связанного списка: При удалении элемента из стека на основе связанного списка, удаляется соответствующий узел, и память, выделенная под этот узел, освобождается с
помощью функции free().
4. Что происходит с элементами стека при его просмотре?
При просмотре элементов стека, они остаются в стеке в неизменном виде. Просто читается значение элемента с вершины стека, но этот элемент не удаляется. Таким образом, элементы
стека не изменяются при его просмотре.
5. Каким образом эффективнее реализовывать стек? От чего это зависит?
Эффективность реализации стека зависит от конкретных требований и ограничений
приложения:
Стек на основе статического массива более эффективен по памяти, если известен максимальный размер стека заранее. 
Он может работать быстрее, чем связанный список, при доступе к элементам по индексу. Однако его размер ограничен.
Стек на основе динамического массива занимает только требуемое количество памяти, однако его эффективность падает из-за
необходимости постоянно перевыделять память в случае расширения/оптимизации сжатия
Стек на основе связанного списка более гибок и способен динамически расти и сжиматься в
зависимости от потребности. Это подходит для случаев, когда размер стека заранее неизвестен
или может изменяться. Эффективность также зависит от операций, которые выполняются чаще: добавление, удаление
или просмотр элементов, а также от общей структуры программы.
